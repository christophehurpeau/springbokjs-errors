{"version":3,"sources":["../src/index.js"],"names":[],"mappings":"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","file":"index.js","sourcesContent":["/* global BROWSER, NODEJS */\nimport { readFileSync } from 'fs'; // #if NODEJS\nimport ParsedError from './ParsedError';\nimport StackTrace from './StackTrace';\nimport StackTraceItem from './StackTraceItem';\n\nconst path = require('path');\nconst stackTrace = require('stack-trace');\nconst sourceMap = require('source-map');\n\nlet sourceMapping;\n\n/**\n * Set path mapping, for instance when you have a vm or docker\n *\n * @param {String} currentPath\n * @param {String} sourcePath\n */\nexport function setPathMapping(currentPath, sourcePath) {\n    sourceMapping = Object.freeze({ current: currentPath, source: sourcePath });\n}\n\n/**\n * Parse an error and extract its stack trace\n *\n * @param  {Error} err\n * @return {ParsedError}\n */\nexport function parse(err) {\n    let parsedError = new ParsedError(err, parseErrorStack(err));\n\n    if (err.previous) {\n        parsedError.previous = parse(err.previous);\n    }\n\n    return parsedError;\n}\n\n/**\n * Parse an error and extract its stack trace\n *\n * @param  {Error} err\n * @return {StackTrace}\n */\nexport function parseErrorStack(err) {\n    let finalStack = new StackTrace();\n    let stack = stackTrace.parse(err);\n\n    const libFiles = new Map();\n    const sourceFiles = new Map();\n\n    stack.forEach((line) => {\n        const fileName = line.fileName;\n        let file;\n\n        if (fileName && fileName.startsWith('/')) {\n            if (libFiles.has(fileName)) {\n                file = libFiles.get(fileName);\n            } else if (BROWSER) {\n                libFiles.set(fileName, file = false);\n            } else {\n                file = {};\n                const dirname = path.dirname(fileName);\n                try {\n                    const fileContent = readFileSync(fileName).toString();\n                    file.fileName = fileName;\n                    file.contents = fileContent;\n                    libFiles.set(fileName, file);\n\n                    try {\n                        let fileNameMap = `${fileName}.map`;\n                        const match = /\\/\\/[#@]\\s*sourceMappingURL=(.*)\\s*$/m.exec(fileContent);\n                        if (match && match[1] && match[1][0] === '/') {\n                            fileNameMap = path.resolve(dirname, match[1]);\n                        }\n\n                        const contents = readFileSync(fileNameMap).toString();\n                        file.fileNameMap = fileNameMap;\n                        file.map = new sourceMap.SourceMapConsumer(contents);\n\n                        if (file.map.sourceRoot) {\n                            file.sourceRoot = path.resolve(dirname, file.map.sourceRoot);\n                        } else {\n                            file.sourceRoot = path.dirname(fileName);\n                        }\n                    } catch (e) {\n                    }\n                } catch (e) {\n                    libFiles.set(fileName, file = false);\n                }\n            }\n        }\n\n        if (file && file.map) {\n            const original = file.map.originalPositionFor({ line: line.lineNumber, column: line.columnNumber });\n            let originalFile;\n\n            if (original.source) {\n                const originalFilePath = path.resolve(file.sourceRoot, original.source);\n\n                if (sourceFiles.has(originalFilePath)) {\n                    originalFile = sourceFiles.get(originalFilePath);\n                } else {\n                    originalFile = { fileName: original.source, filePath: originalFilePath };\n                    sourceFiles.set(originalFilePath, originalFile);\n\n                    if (file.map.sourcesContent) {\n                        const sourceIndex = file.map.sources.indexOf(original.source);\n                        originalFile.contents = sourceIndex !== -1 && file.map.sourcesContent[sourceIndex];\n                    }\n\n                    if (NODEJS) {\n                        if (!originalFile.contents) {\n                            Object.defineProperty(originalFile, 'contents', {\n                                configurable: true,\n                                get: function get() {\n                                    let contents;\n                                    try {\n                                        contents = readFileSync(originalFilePath).toString();\n                                    } catch (err) {\n                                    }\n\n                                    Object.defineProperty(originalFile, 'contents', { value: contents });\n                                    return contents;\n                                },\n                            });\n                        }\n                    }\n                }\n\n                line.compiledFileName = line.fileName;\n                line.compiledLineNumber = line.lineNumber;\n                line.compiledColumnNumber = line.columnNumber;\n\n                line.file = originalFile;\n                line.fileName = originalFile.filePath;\n                line.lineNumber = original.line;\n                line.columnNumber = original.column;\n                if (original.name) {\n                    line.methodName = original.name;\n                }\n            }\n        }\n\n        if (!line.file && file && file.contents) {\n            line.file = {\n                fileName: file.fileName,\n                filePath: file.fileName,\n                contents: file.contents,\n            };\n        }\n\n        finalStack.items.push(new StackTraceItem(line, sourceMapping));\n    });\n\n    return finalStack;\n}\n"]}