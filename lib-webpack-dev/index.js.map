{"version":3,"sources":["../src/index.js"],"names":["ParsedError","StackTrace","StackTraceItem","path","require","stackTrace","sourceMap","sourceMapping","setPathMapping","currentPath","sourcePath","Object","freeze","current","source","parse","err","parsedError","parseErrorStack","previous","finalStack","stack","libFiles","Map","sourceFiles","forEach","line","fileName","file","startsWith","has","get","set","map","original","originalPositionFor","lineNumber","column","columnNumber","originalFile","originalFilePath","resolve","sourceRoot","filePath","sourcesContent","sourceIndex","sources","indexOf","contents","compiledFileName","compiledLineNumber","compiledColumnNumber","name","methodName","items","push"],"mappings":"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","file":"index.js","sourcesContent":["/* global BROWSER, NODEJS */\nimport { readFileSync } from 'fs'; // #if NODEJS\nimport ParsedError from './ParsedError';\nimport StackTrace from './StackTrace';\nimport StackTraceItem from './StackTraceItem';\n\nconst path = require('path');\nconst stackTrace = require('stack-trace');\nconst sourceMap = require('source-map');\n\nlet sourceMapping;\n\n/**\n * Set path mapping, for instance when you have a vm or docker\n *\n * @param {String} currentPath\n * @param {String} sourcePath\n */\nexport function setPathMapping(currentPath, sourcePath) {\n  sourceMapping = Object.freeze({ current: currentPath, source: sourcePath });\n}\n\n/**\n * Parse an error and extract its stack trace\n *\n * @param  {Error} err\n * @return {ParsedError}\n */\nexport function parse(err) {\n  let parsedError = new ParsedError(err, parseErrorStack(err));\n\n  if (err.previous) {\n    parsedError.previous = parse(err.previous);\n  }\n\n  return parsedError;\n}\n\n/**\n * Parse an error and extract its stack trace\n *\n * @param  {Error} err\n * @return {StackTrace}\n */\nexport function parseErrorStack(err) {\n  let finalStack = new StackTrace();\n  let stack = stackTrace.parse(err);\n\n  const libFiles = new Map();\n  const sourceFiles = new Map();\n\n  stack.forEach((line) => {\n    const fileName = line.fileName;\n    let file;\n\n    if (fileName && fileName.startsWith('/')) {\n      if (libFiles.has(fileName)) {\n        file = libFiles.get(fileName);\n      } else if (BROWSER) {\n        libFiles.set(fileName, file = false);\n      } else {\n        file = {};\n        const dirname = path.dirname(fileName);\n        try {\n          const fileContent = readFileSync(fileName).toString();\n          file.fileName = fileName;\n          file.contents = fileContent;\n          libFiles.set(fileName, file);\n\n          try {\n            let fileNameMap = `${fileName}.map`;\n            const match = /\\/\\/[#@]\\s*sourceMappingURL=(.*)\\s*$/m.exec(fileContent);\n            if (match && match[1] && match[1][0] === '/') {\n              fileNameMap = path.resolve(dirname, match[1]);\n            }\n\n            const contents = readFileSync(fileNameMap).toString();\n            file.fileNameMap = fileNameMap;\n            file.map = new sourceMap.SourceMapConsumer(contents);\n\n            if (file.map.sourceRoot) {\n              file.sourceRoot = path.resolve(dirname, file.map.sourceRoot);\n            } else {\n              file.sourceRoot = path.dirname(fileName);\n            }\n          } catch (e) {\n          }\n        } catch (e) {\n          libFiles.set(fileName, file = false);\n        }\n      }\n    }\n\n    if (file && file.map) {\n      const original = file.map.originalPositionFor({\n        line: line.lineNumber,\n        column: line.columnNumber,\n      });\n      let originalFile;\n\n      if (original.source) {\n        const originalFilePath = path.resolve(file.sourceRoot, original.source);\n\n        if (sourceFiles.has(originalFilePath)) {\n          originalFile = sourceFiles.get(originalFilePath);\n        } else {\n          originalFile = { fileName: original.source, filePath: originalFilePath };\n          sourceFiles.set(originalFilePath, originalFile);\n\n          if (file.map.sourcesContent) {\n            const sourceIndex = file.map.sources.indexOf(original.source);\n            originalFile.contents = sourceIndex !== -1 && file.map.sourcesContent[sourceIndex];\n          }\n\n          if (NODEJS) {\n            if (!originalFile.contents) {\n              Object.defineProperty(originalFile, 'contents', {\n                configurable: true,\n                get: function get() {\n                  let contents;\n                  try {\n                    contents = readFileSync(originalFilePath).toString();\n                  } catch (err) {\n                  }\n\n                  Object.defineProperty(originalFile, 'contents', { value: contents });\n                  return contents;\n                },\n              });\n            }\n          }\n        }\n\n        line.compiledFileName = line.fileName;\n        line.compiledLineNumber = line.lineNumber;\n        line.compiledColumnNumber = line.columnNumber;\n\n        line.file = originalFile;\n        line.fileName = originalFile.filePath;\n        line.lineNumber = original.line;\n        line.columnNumber = original.column;\n        if (original.name) {\n          line.methodName = original.name;\n        }\n      }\n    }\n\n    if (!line.file && file && file.contents) {\n      line.file = {\n        fileName: file.fileName,\n        filePath: file.fileName,\n        contents: file.contents,\n      };\n    }\n\n    finalStack.items.push(new StackTraceItem(line, sourceMapping));\n  });\n\n  return finalStack;\n}\n"]}