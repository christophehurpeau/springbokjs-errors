{"version":3,"sources":["../src/index.js"],"names":["readFileSync","ParsedError","StackTrace","StackTraceItem","path","require","stackTrace","sourceMap","sourceMapping","setPathMapping","currentPath","sourcePath","Object","freeze","current","source","parseErrorStack","err","finalStack","stack","parse","libFiles","Map","sourceFiles","forEach","line","fileName","file","startsWith","has","get","dirname","fileContent","toString","contents","set","fileNameMap","match","exec","resolve","map","SourceMapConsumer","sourceRoot","e","original","originalPositionFor","lineNumber","column","columnNumber","originalFile","originalFilePath","filePath","sourcesContent","sourceIndex","sources","indexOf","defineProperty","configurable","value","compiledFileName","compiledLineNumber","compiledColumnNumber","name","methodName","items","push","parsedError","previous"],"mappings":"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","file":"index.js","sourcesContent":["/* global BROWSER, NODEJS */\nimport { readFileSync } from 'fs';\nimport ParsedError from './ParsedError';\nimport StackTrace from './StackTrace';\nimport StackTraceItem from './StackTraceItem';\n\nconst path = require('path');\nconst stackTrace = require('stack-trace');\nconst sourceMap = require('source-map');\n\nlet sourceMapping;\n\n/**\n * Set path mapping, for instance when you have a vm or docker\n *\n * @param {String} currentPath\n * @param {String} sourcePath\n */\nexport function setPathMapping(currentPath, sourcePath) {\n  sourceMapping = Object.freeze({ current: currentPath, source: sourcePath });\n}\n\n/**\n * Parse an error and extract its stack trace\n *\n * @param  {Error} err\n * @return {StackTrace}\n */\nexport function parseErrorStack(err) {\n  let finalStack = new StackTrace();\n  let stack = stackTrace.parse(err);\n\n  const libFiles = new Map();\n  const sourceFiles = new Map();\n\n  stack.forEach((line) => {\n    const fileName = line.fileName;\n    let file;\n\n    if (fileName && fileName.startsWith('/')) {\n      if (libFiles.has(fileName)) {\n        file = libFiles.get(fileName);\n      } else if (BROWSER) {\n        libFiles.set(fileName, file = false);\n      } else {\n        file = {};\n        const dirname = path.dirname(fileName);\n        try {\n          const fileContent = readFileSync(fileName).toString();\n          file.fileName = fileName;\n          file.contents = fileContent;\n          libFiles.set(fileName, file);\n\n          try {\n            let fileNameMap = `${fileName}.map`;\n            const match = /\\/\\/[#@]\\s*sourceMappingURL=(.*)\\s*$/m.exec(fileContent);\n            if (match && match[1] && match[1][0] === '/') {\n              fileNameMap = path.resolve(dirname, match[1]);\n            }\n\n            const contents = readFileSync(fileNameMap).toString();\n            file.fileNameMap = fileNameMap;\n            file.map = new sourceMap.SourceMapConsumer(contents);\n\n            if (file.map.sourceRoot) {\n              file.sourceRoot = path.resolve(dirname, file.map.sourceRoot);\n            } else {\n              file.sourceRoot = path.dirname(fileName);\n            }\n          } catch (e) {\n          }\n        } catch (e) {\n          libFiles.set(fileName, file = false);\n        }\n      }\n    }\n\n    if (file && file.map) {\n      const original = file.map.originalPositionFor({\n        line: line.lineNumber,\n        column: line.columnNumber,\n      });\n      let originalFile;\n\n      if (original.source) {\n        const originalFilePath = path.resolve(file.sourceRoot, original.source);\n\n        if (sourceFiles.has(originalFilePath)) {\n          originalFile = sourceFiles.get(originalFilePath);\n        } else {\n          originalFile = { fileName: original.source, filePath: originalFilePath };\n          sourceFiles.set(originalFilePath, originalFile);\n\n          if (file.map.sourcesContent) {\n            const sourceIndex = file.map.sources.indexOf(original.source);\n            originalFile.contents = sourceIndex !== -1 && file.map.sourcesContent[sourceIndex];\n          }\n\n          if (NODEJS) {\n            if (!originalFile.contents) {\n              Object.defineProperty(originalFile, 'contents', {\n                configurable: true,\n                get: function get() {\n                  let contents;\n                  try {\n                    contents = readFileSync(originalFilePath).toString();\n                  } catch (err) {\n                  }\n\n                  Object.defineProperty(originalFile, 'contents', { value: contents });\n                  return contents;\n                },\n              });\n            }\n          }\n        }\n\n        line.compiledFileName = line.fileName;\n        line.compiledLineNumber = line.lineNumber;\n        line.compiledColumnNumber = line.columnNumber;\n\n        line.file = originalFile;\n        line.fileName = originalFile.filePath;\n        line.lineNumber = original.line;\n        line.columnNumber = original.column;\n        if (original.name) {\n          line.methodName = original.name;\n        }\n      }\n    }\n\n    if (!line.file && file && file.contents) {\n      line.file = {\n        fileName: file.fileName,\n        filePath: file.fileName,\n        contents: file.contents,\n      };\n    }\n\n    finalStack.items.push(new StackTraceItem(line, sourceMapping));\n  });\n\n  return finalStack;\n}\n\n/**\n * Parse an error and extract its stack trace\n *\n * @param  {Error} err\n * @return {ParsedError}\n */\nexport function parse(err) {\n  let parsedError = new ParsedError(err, parseErrorStack(err));\n\n  if (err.previous) {\n    parsedError.previous = parse(err.previous);\n  }\n\n  return parsedError;\n}\n"]}