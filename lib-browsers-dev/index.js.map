{"version":3,"sources":["../src/index.js"],"names":["setPathMapping","parseErrorStack","parse","path","require","stackTrace","sourceMap","sourceMapping","currentPath","sourcePath","Object","freeze","current","source","err","finalStack","stack","libFiles","Map","sourceFiles","forEach","line","fileName","file","startsWith","has","get","set","map","original","originalPositionFor","lineNumber","column","columnNumber","originalFile","originalFilePath","resolve","sourceRoot","filePath","sourcesContent","sourceIndex","sources","indexOf","contents","compiledFileName","compiledLineNumber","compiledColumnNumber","name","methodName","items","push","parsedError","previous"],"mappings":"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","file":"index.js","sourcesContent":["/* global BROWSER, NODEJS */\nimport { readFileSync } from 'fs';\nimport ParsedError from './ParsedError';\nimport StackTrace from './StackTrace';\nimport StackTraceItem from './StackTraceItem';\n\nconst path = require('path');\nconst stackTrace = require('stack-trace');\nconst sourceMap = require('source-map');\n\nlet sourceMapping;\n\n/**\n * Set path mapping, for instance when you have a vm or docker\n *\n * @param {String} currentPath\n * @param {String} sourcePath\n */\nexport function setPathMapping(currentPath, sourcePath) {\n  sourceMapping = Object.freeze({ current: currentPath, source: sourcePath });\n}\n\n/**\n * Parse an error and extract its stack trace\n *\n * @param  {Error} err\n * @return {StackTrace}\n */\nexport function parseErrorStack(err) {\n  let finalStack = new StackTrace();\n  let stack = stackTrace.parse(err);\n\n  const libFiles = new Map();\n  const sourceFiles = new Map();\n\n  stack.forEach((line) => {\n    const fileName = line.fileName;\n    let file;\n\n    if (fileName && fileName.startsWith('/')) {\n      if (libFiles.has(fileName)) {\n        file = libFiles.get(fileName);\n      } else if (BROWSER) {\n        libFiles.set(fileName, file = false);\n      } else {\n        file = {};\n        const dirname = path.dirname(fileName);\n        try {\n          const fileContent = readFileSync(fileName).toString();\n          file.fileName = fileName;\n          file.contents = fileContent;\n          libFiles.set(fileName, file);\n\n          try {\n            let fileNameMap = `${fileName}.map`;\n            const match = /\\/\\/[#@]\\s*sourceMappingURL=(.*)\\s*$/m.exec(fileContent);\n            if (match && match[1] && match[1][0] === '/') {\n              fileNameMap = path.resolve(dirname, match[1]);\n            }\n\n            const contents = readFileSync(fileNameMap).toString();\n            file.fileNameMap = fileNameMap;\n            file.map = new sourceMap.SourceMapConsumer(contents);\n\n            if (file.map.sourceRoot) {\n              file.sourceRoot = path.resolve(dirname, file.map.sourceRoot);\n            } else {\n              file.sourceRoot = path.dirname(fileName);\n            }\n          } catch (e) {\n          }\n        } catch (e) {\n          libFiles.set(fileName, file = false);\n        }\n      }\n    }\n\n    if (file && file.map) {\n      const original = file.map.originalPositionFor({\n        line: line.lineNumber,\n        column: line.columnNumber,\n      });\n      let originalFile;\n\n      if (original.source) {\n        const originalFilePath = path.resolve(file.sourceRoot, original.source);\n\n        if (sourceFiles.has(originalFilePath)) {\n          originalFile = sourceFiles.get(originalFilePath);\n        } else {\n          originalFile = { fileName: original.source, filePath: originalFilePath };\n          sourceFiles.set(originalFilePath, originalFile);\n\n          if (file.map.sourcesContent) {\n            const sourceIndex = file.map.sources.indexOf(original.source);\n            originalFile.contents = sourceIndex !== -1 && file.map.sourcesContent[sourceIndex];\n          }\n\n          if (NODEJS) {\n            if (!originalFile.contents) {\n              Object.defineProperty(originalFile, 'contents', {\n                configurable: true,\n                get: function get() {\n                  let contents;\n                  try {\n                    contents = readFileSync(originalFilePath).toString();\n                  } catch (err) {\n                  }\n\n                  Object.defineProperty(originalFile, 'contents', { value: contents });\n                  return contents;\n                },\n              });\n            }\n          }\n        }\n\n        line.compiledFileName = line.fileName;\n        line.compiledLineNumber = line.lineNumber;\n        line.compiledColumnNumber = line.columnNumber;\n\n        line.file = originalFile;\n        line.fileName = originalFile.filePath;\n        line.lineNumber = original.line;\n        line.columnNumber = original.column;\n        if (original.name) {\n          line.methodName = original.name;\n        }\n      }\n    }\n\n    if (!line.file && file && file.contents) {\n      line.file = {\n        fileName: file.fileName,\n        filePath: file.fileName,\n        contents: file.contents,\n      };\n    }\n\n    finalStack.items.push(new StackTraceItem(line, sourceMapping));\n  });\n\n  return finalStack;\n}\n\n/**\n * Parse an error and extract its stack trace\n *\n * @param  {Error} err\n * @return {ParsedError}\n */\nexport function parse(err) {\n  let parsedError = new ParsedError(err, parseErrorStack(err));\n\n  if (err.previous) {\n    parsedError.previous = parse(err.previous);\n  }\n\n  return parsedError;\n}\n"]}